{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\nexport default function useDebounce(value, delay) {\n  _s();\n  // Состояние и сеттер для отложенного значения\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    // Выставить debouncedValue равным value (переданное значение)\n    // после заданной задержки\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // Вернуть функцию очистки, которая будет вызываться каждый раз, когда ...\n    // ... useEffect вызван снова. useEffect будет вызван снова, только если ...\n    // ... value будет изменено (смотри ниже массив зависимостей).\n    // Так мы избегаем изменений debouncedValue, если значение value ...\n    // ... поменялось в рамках интервала задержки.\n    // Таймаут очищается и стартует снова.\n    // Что бы сложить это воедино: если пользователь печатает что-то внутри ...\n    // ... нашего приложения в поле поиска, мы не хотим, чтобы debouncedValue...\n    // ... не менялось до тех пор, пока он не прекратит печатать дольше, чем 500ms.\n    return () => {\n      clearTimeout(handler);\n    };\n  },\n  // Вызывается снова, только если значение изменится\n  // мы так же можем добавить переменную \"delay\" в массива зависимостей ...\n  // ... если вы собираетесь менять ее динамически.\n  [value]);\n  return debouncedValue;\n}\n_s(useDebounce, \"KDuPAtDOgxm8PU6legVJOb3oOmA=\");","map":{"version":3,"names":["useState","useEffect","useDebounce","value","delay","_s","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout"],"sources":["/home/user/Desktop/app-typescript/src/hooks/useDebounce.tsx"],"sourcesContent":["import { useState, useEffect } from \"react\";\n\nexport default function useDebounce(value: string, delay: number) {\n\t// Состояние и сеттер для отложенного значения\n\tconst [debouncedValue, setDebouncedValue] = useState(value);\n\n\tuseEffect(\n\t\t() => {\n\t\t\t// Выставить debouncedValue равным value (переданное значение)\n\t\t\t// после заданной задержки\n\t\t\tconst handler = setTimeout(() => {\n\t\t\t\tsetDebouncedValue(value);\n\t\t\t}, delay);\n\n\t\t\t// Вернуть функцию очистки, которая будет вызываться каждый раз, когда ...\n\t\t\t// ... useEffect вызван снова. useEffect будет вызван снова, только если ...\n\t\t\t// ... value будет изменено (смотри ниже массив зависимостей).\n\t\t\t// Так мы избегаем изменений debouncedValue, если значение value ...\n\t\t\t// ... поменялось в рамках интервала задержки.\n\t\t\t// Таймаут очищается и стартует снова.\n\t\t\t// Что бы сложить это воедино: если пользователь печатает что-то внутри ...\n\t\t\t// ... нашего приложения в поле поиска, мы не хотим, чтобы debouncedValue...\n\t\t\t// ... не менялось до тех пор, пока он не прекратит печатать дольше, чем 500ms.\n\t\t\treturn () => {\n\t\t\t\tclearTimeout(handler);\n\t\t\t};\n\t\t},\n\t\t// Вызывается снова, только если значение изменится\n\t\t// мы так же можем добавить переменную \"delay\" в массива зависимостей ...\n\t\t// ... если вы собираетесь менять ее динамически.\n\t\t[value]\n\t);\n\n\treturn debouncedValue;\n}\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAE3C,eAAe,SAASC,WAAWA,CAACC,KAAa,EAAEC,KAAa,EAAE;EAAAC,EAAA;EACjE;EACA,MAAM,CAACC,cAAc,EAAEC,iBAAiB,CAAC,GAAGP,QAAQ,CAACG,KAAK,CAAC;EAE3DF,SAAS,CACR,MAAM;IACL;IACA;IACA,MAAMO,OAAO,GAAGC,UAAU,CAAC,MAAM;MAChCF,iBAAiB,CAACJ,KAAK,CAAC;IACzB,CAAC,EAAEC,KAAK,CAAC;;IAET;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAO,MAAM;MACZM,YAAY,CAACF,OAAO,CAAC;IACtB,CAAC;EACF,CAAC;EACD;EACA;EACA;EACA,CAACL,KAAK,CACP,CAAC;EAED,OAAOG,cAAc;AACtB;AAACD,EAAA,CAhCuBH,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}